/**
 * @file async_server.cpp
 */

/*
 * The following license applies to the code in this file:
 *
 * **************************************************************************
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * **************************************************************************
 *
 * Author: Dr. RÃ¼diger Berlich of Gemfony scientific UG (haftungsbeschraenkt)
 * See http://www.gemfony.eu for further information.
 *
 * This code is based on the Beast Websocket library by Vinnie Falco, as published
 * together with Boost 1.66 and above. For further information on Beast, see
 * https://github.com/boostorg/beast for the latest release, or download
 * Boost 1.66 or newer from http://www.boost.org .
 */

#include "async_websocket_server.hpp"

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

async_websocket_client::async_websocket_client(
	const std::string& address
	, unsigned short port
	, bool verbose_control_frames
)
	: m_address(address)
   , m_port(port)
	, m_verbose_control_frames(verbose_control_frames)
{
	// Set the auto_fragment option, so control frames are delivered timely
	m_ws.auto_fragment(true);
	m_ws.write_buffer_size(16384);

	// Set the transfer mode according to the defines in CMakeLists.txt
	set_transfer_mode(m_ws);

	// Set a control-frame callback
	f_when_control_frame_arrived
		= [this](frame_type frame_t, string_view s) {
		if(this->m_verbose_control_frames) {
			if (boost::beast::websocket::frame_type::close == frame_t) {
				std::cout << "Client has received a close frame" << std::endl;
			} else if (boost::beast::websocket::frame_type::ping == frame_t) {
				std::cout << "Client has received a ping frame" << std::endl;
			} else if (boost::beast::websocket::frame_type::pong == frame_t) {
				std::cout << "Client has received a pong frame" << std::endl;
			}
		}
	};

	// Set the callback to be executed on every incoming control frame.
	m_ws.control_callback(f_when_control_frame_arrived);
}

/******************************************************************************************/

void async_websocket_client::run() {
	// Start looking up the domain name. This call will return immediately,
	// when_resolved() will be called once the operation is complete.
	auto self = shared_from_this();
	m_resolver.async_resolve(
		m_address
		, std::to_string(m_port)
		, [self](
			boost::system::error_code ec
			, const resolver::results_type &results
		) {
			self->when_resolved(ec, results);
		}
	);

	// We need an additional thread for the processing of incoming work items
	std::thread processing_thread (
		[this]() {
			this->m_io_context.run();
		}
	);

	// This call will block until no more work remains in the ASIO work queue
	m_io_context.run();

	// Finally close all outstanding connections
	std::cout << "async_websocket_client::async_start_run(): Closing down remaining connections" << std::endl;
	processing_thread.join();
	do_close(m_close_code);
}

/******************************************************************************************/

void async_websocket_client::when_resolved(
	boost::system::error_code ec
	, const resolver::results_type &results
) {
	if(ec) {
		std::cout
			<< "In async_websocket_client::when_resolved():" << std::endl
		   << "Got ec(\"" << ec.message() << "\"). async_connect() will not be executed." << std::endl
			<< "This will terminate the client." << std::endl;

		// Give the audience a hint why we are terminating
		m_close_code = boost::beast::websocket::close_code::going_away;

		return;
	}

	// Make the connection on the endpoint we get from a lookup
	auto self = shared_from_this();
	boost::asio::async_connect(
		m_ws.next_layer()
		, results.begin()
		, results.end()
		, [self](boost::system::error_code ec, boost::asio::ip::tcp::resolver::iterator /* unused */) {
			self->when_connected(ec);
		}
	);
}

/******************************************************************************************/

void async_websocket_client::when_connected(boost::system::error_code ec) {
	if(ec) {
		std::cout
			<< "In async_websocket_client::when_connected():" << std::endl
			<< "Got ec(\"" << ec.message() << "\"). async_handshake() will not be executed." << std::endl
			<< "This will terminate the client." << std::endl;

		// Give the audience a hint why we are terminating
		m_close_code = boost::beast::websocket::close_code::going_away;

		return;
	}

	// Perform the websocket handshake
	auto self = shared_from_this();
	m_ws.async_handshake(
		m_address
		, "/"
		, [self](boost::system::error_code ec) {
			self->when_handshake_complete(ec);
		}
	);
}

/******************************************************************************************/

void async_websocket_client::when_handshake_complete(boost::system::error_code ec) {
	if(ec) {
		std::cout
			<< "In async_websocket_client::when_handshake_complete():" << std::endl
			<< "Got ec(\"" << ec.message() << "\"). async_start_write() will not be executed." << std::endl
			<< "This will terminate the client." << std::endl;

		// Give the audience a hint why we are terminating
		m_close_code = boost::beast::websocket::close_code::going_away;

		// This will terminate the client
		return;
	}

	// Send the first command to the server
	async_start_write(
		m_command_container.reset(
			payload_command::GETDATA
		).to_string()
	);

	// Start the read cycle -- it will keep itself alife
	async_start_read();
}

/******************************************************************************************/

void async_websocket_client::async_start_write(const std::string& message) {
	// We need to persist the message for asynchronous operations.
	// It is hence stored in a class variable.
	m_outgoing_message = message;

	// Send the message
	auto self = shared_from_this();
	m_ws.async_write(
		boost::asio::buffer(m_outgoing_message)
		, [self](
			boost::system::error_code ec
			, std::size_t nBytesTransferred
		) {
			self->when_written(ec, nBytesTransferred);
		}
	);
}

/******************************************************************************************/

void async_websocket_client::when_written(
	boost::system::error_code ec
	, std::size_t /* nothing */
) {
	if(ec) {
		std::cout
			<< "In async_websocket_client::when_written():" << std::endl
			<< "Got ec(\"" << ec.message() << "\")." << std::endl
			<< "This will terminate the client." << std::endl;

		// Give the audience a hint why we are terminating
		m_close_code = boost::beast::websocket::close_code::going_away;

		// This will terminate the client
		return;
	}

	// Clear the outgoing message -- no longer needed
	m_outgoing_message.clear();
}

/******************************************************************************************/

void async_websocket_client::async_start_read() {
	auto self = shared_from_this();
	m_ws.async_read(
		m_incoming_buffer
		, [self] (
			boost::system::error_code ec
			, std::size_t nBytesTransferred
		) {
			self->when_read(ec, nBytesTransferred);
		}
	);
}

/******************************************************************************************/

void async_websocket_client::when_read(
	boost::system::error_code ec
	, std::size_t /* nothing */
) {
	if(ec) {
		std::cout
			<< "In async_websocket_client::when_read():" << std::endl
			<< "Got ec(\"" << ec.message() << "\"). No  more processing will take place" << std::endl
			<< "This will terminate the client." << std::endl;

		// Give the audience a hint why we are terminating
		m_close_code = boost::beast::websocket::close_code::going_away;

		// This will terminate the client
		return;
	}

	// Deal with the message and send a response back. Processing
	// of work items is done inside of process_request().
	try {
		// Start asynchronous processing of the work item.
		// As we need to keep the read-cycle alife in parallel,
		// this requires that the io_context::run()-function is
		// started in at least two threads.
		auto self = shared_from_this();
		m_io_context.post(
			[self]() {
				self->process_request();
			}
		);

		// Start a new read cycle so we may react to control frames
		// (in particular ping and close)
		async_start_read();
	} catch(...) {
		// Give the audience a hint why we are terminating
		m_close_code = boost::beast::websocket::close_code::internal_error;
	}
}

/******************************************************************************************/

void async_websocket_client::process_request() {
	// Extract the string from the buffer
	auto message = boost::beast::buffers_to_string(m_incoming_buffer.data());

	// De-serialize the object
	try {
		m_command_container.from_string(message);
	} catch(...) {
		throw std::runtime_error("async_websocket_client::process_request(): Caught exception while de-serializing");
	}

	// Clear the buffer, so we may later fill it with data to be sent
	m_incoming_buffer.consume(m_incoming_buffer.size());

	// Extract the command
	auto inboundCommand = m_command_container.get_command();

	// Act on the command received
	switch(inboundCommand) {
		case payload_command::COMPUTE: {
			// Process the work item
			m_command_container.process();

			// Set the command for the way back to the server
			m_command_container.set_command(payload_command::RESULT);
		} break;

		case payload_command::NODATA: // This must be a command payload
		case payload_command::ERROR: { // We simply ask for new work
			// sleep for a short while (between 10 and 50 milliseconds, randomly),
			// before we ask for new work.
			std::uniform_int_distribution<> dist(10, 50);
			std::this_thread::sleep_for(std::chrono::milliseconds(dist(m_rng_engine)));

			// Tell the server again we need work
			m_command_container.reset(payload_command::GETDATA);
		} break;

		default: {
			throw std::runtime_error(
				"async_websocket_client::process_request(): Got unknown or invalid command " + boost::lexical_cast<std::string>(inboundCommand)
			);
		} break;
	}

	// Serialize the object again and return the result
	async_start_write(m_command_container.to_string());
}

/******************************************************************************************/

void async_websocket_client::do_close(close_code cc) {
	if(m_ws.is_open()) {
		m_ws.close(cc);
	}

	if(m_ws.next_layer().is_open()) {
		boost::system::error_code ec;

		m_ws.next_layer().shutdown(socket::shutdown_both, ec);
		m_ws.next_layer().close(ec);

		if(ec) {
			std::cout
				<< "In async_websocket_client::do_close():" << std::endl
				<< "Got ec(\"" << ec.message() << "\")." << std::endl
				<< "We will throw an exception, as there are no other options left" << std::endl;

			// Not much more we can do
			throw std::runtime_error("async_websocket_client::do_close(): Shutdown of next layer has failed");
		}
	}
}

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

async_websocket_server_session::async_websocket_server_session(
	boost::asio::ip::tcp::socket socket
	, std::function<bool(payload_base*& plb_ptr)> get_next_payload_item
	, std::function<bool()> check_server_stopped
	, std::function<void(bool)> server_sign_on
	, std::size_t ping_interval
	, bool verbose_control_frames
)
	: m_ws(std::move(socket))
	, m_strand(m_ws.get_executor())
	, m_timer(m_ws.get_executor().context(), (std::chrono::steady_clock::time_point::max)())
	, m_get_next_payload_item(std::move(get_next_payload_item))
	, m_check_server_stopped(std::move(check_server_stopped))
	, m_server_sign_on(std::move(server_sign_on))
   , m_ping_interval(std::chrono::seconds(ping_interval))
	, m_verbose_control_frames(verbose_control_frames)
{
	// Set the auto_fragment option, so control frames are delivered timely
	m_ws.auto_fragment(true);
	m_ws.write_buffer_size(16384);

	// Set the transfer mode according to the defines in CMakeLists.txt
	set_transfer_mode(m_ws);
}

/******************************************************************************************/

void async_websocket_server_session::async_start_run() {
	// --------------------------------------------------------------------------
	// Make sure we run on the correct strand. Fixes a problem flagged in this
	// post: https://github.com/boostorg/beast/issues/1073 . Follows the "advanced_server"
	// example of Beast.
	if(! m_strand.running_in_this_thread()) {
		auto self = shared_from_this();
		return boost::asio::post(
			boost::asio::bind_executor(
				m_strand
				, [self]() {
					self->async_start_run();
				}
			)
		);
	}

	// --------------------------------------------------------------------------
	// Prepare ping cycle. It must start after the handshake, upon whose
	// completion the when_connection_accepted() function is called.
	// async_start_ping() is executed from there.

	// Set a control-frame callback
	f_when_control_frame_arrived
		= [this](frame_type frame_t, string_view s) {
		if(
			// We might have received a pong as an answer to a our own ping,
			// or someone might be sending us pings. In either case the line is active.
			boost::beast::websocket::frame_type::pong==frame_t
			|| boost::beast::websocket::frame_type::ping==frame_t
		) {
			// Note that the connection is alive
			this->m_ping_state = ping_state::CONNECTION_IS_ALIVE;
		}

		// Let the audience know what type of control frame we have received
		// if the user has requested it.
		if(this->m_verbose_control_frames) {
			if (boost::beast::websocket::frame_type::close == frame_t) {
				std::cout << "Server session has received a close frame" << std::endl;
			} else if (boost::beast::websocket::frame_type::ping == frame_t) {
				std::cout << "Server session has received a ping frame" << std::endl;
			} else if (boost::beast::websocket::frame_type::pong == frame_t) {
				std::cout << "Server session has received a pong frame" << std::endl;
			}
		}
	};

	// Set the callback to be executed on every incoming control frame.
	m_ws.control_callback(f_when_control_frame_arrived);

	// --------------------------------------------------------------------------
	// Connections and communication

	async_start_accept();

	// --------------------------------------------------------------------------
	// This function will terminate shortly after it was called, as all operations
	// are performed asynchronously.
}

/******************************************************************************************/

void async_websocket_server_session::async_start_ping() {
	// Set the timer
	m_timer.expires_after(m_ping_interval);

	// Start to wait asynchronously. This call will return immediately.
	// when_timer_fired() will be called once the timer has expired.
	auto self = shared_from_this();
	m_timer.async_wait(
		boost::asio::bind_executor(
			m_strand
			, [self](boost::system::error_code ec) {
				self->when_timer_fired(ec);
			}
		)
	);

	// Setting the ping state must be done before the ping is sent, or
	// else the pong might arrive before the SENDING_PING state is set
	// and we might overwrite the CONNECTION_IS_ALIVE state set by the
	// control-frame callback
	m_ping_state = ping_state::SENDING_PING;

	// Start the ping session
	m_ws.async_ping(
		m_ping_data
		, boost::asio::bind_executor(
			m_strand
			, [self](boost::system::error_code ec) {
				self->when_ping_sent(ec);
			}
		)
	);
}

/******************************************************************************************/

void async_websocket_server_session::when_ping_sent(boost::system::error_code ec) {
	if(ec) {
		if(ec != boost::asio::error::operation_aborted) {
			std::cerr << "when_ping_sent: " << ec.message() << std::endl;
		}

		m_ping_state = ping_state::CONNECTION_IS_STALE;
	}
}

/******************************************************************************************/

void async_websocket_server_session::when_timer_fired(boost::system::error_code ec) {
	if(ec) {
		if(ec != boost::asio::error::operation_aborted) {
			std::cerr << "when_timer_fired: " << ec.message() << std::endl;
		}

		m_ping_state = ping_state::CONNECTION_IS_STALE;
		return;
	}

	if(m_ping_state == ping_state::CONNECTION_IS_ALIVE) {
		// Start the next ping session, if this is a healthy connection
		async_start_ping();
		return;
	} else {
		m_ping_state = ping_state::CONNECTION_IS_STALE;

		if(!this->m_check_server_stopped()) {
			// Either this is a stale connection or the SENDING_PING flag is still set
			std::cout
				<< "async_websocket_server_session::when_timer_fired(): Connection is dead: " << m_ping_state << std::endl;
		}
		return;
	}
}

/******************************************************************************************/

void async_websocket_server_session::async_start_accept() {
	// This function initiates an asynchronous chain of callbacks, where each callback is
	// executed when the previous call (here: async_accept) is completed. Error handling is
	// done in the callback, using an error code provided by Boost.Beast and/or Boost.ASIO.
	auto self = shared_from_this();
	m_ws.async_accept(
		boost::asio::bind_executor(
			m_strand
			, [self](boost::system::error_code ec) {
				self->when_connection_accepted(ec);
			}
		)
	);
}

/******************************************************************************************/

void async_websocket_server_session::when_connection_accepted(boost::system::error_code ec) {
	if(ec) {
		std::cerr << "when_connection_accepted: "  << ec.message() << std::endl;

		do_close(boost::beast::websocket::close_code::going_away);

		return;
	}

	// Make it known to the server that a new session is alive
	m_server_sign_on(true);

	// Start reading an incoming message. This
	// call will return immediately.
	async_start_read();

	// Start the ping cycle
	async_start_ping();
}

/******************************************************************************************/

void async_websocket_server_session::async_start_read() {
	// Read a message into our buffer
	auto self = shared_from_this();
	m_ws.async_read(
		m_incoming_buffer
		, boost::asio::bind_executor(
			m_strand
			, [self](
				boost::system::error_code ec
				, std::size_t nBytesTransferred
			) {
				self->when_read(ec, nBytesTransferred);
			}
		)
	);
}

/******************************************************************************************/

void async_websocket_server_session::when_read(
	boost::system::error_code ec
	, std::size_t /* nothing */
) {
	if(ec) {
		if(ec != boost::beast::websocket::error::closed) {
			std::cerr << "when_read: " << ec.message() << std::endl;
		}

		do_close(boost::beast::websocket::close_code::going_away);
	 	return;
	}

	// Deal with the message and send a response back
	try {
		async_start_write(process_request());
	} catch(...) {
		do_close(boost::beast::websocket::close_code::internal_error);
		return;
	}
}

/******************************************************************************************/

void async_websocket_server_session::async_start_write(const std::string& message) {
	// We need to persist the message for asynchronous operations
	m_outgoing_message = message;

	// Echo the message
	auto self = shared_from_this();
	m_ws.async_write(
		boost::asio::buffer(m_outgoing_message)
		, boost::asio::bind_executor(
			m_strand
			, [self](
				boost::system::error_code ec
				, std::size_t nBytesTransferred
			) {
				self->when_written(ec, nBytesTransferred);
			}
		)
	);
}

/******************************************************************************************/

void async_websocket_server_session::when_written(
	boost::system::error_code ec
	, std::size_t /* nothing */
) {
	if(ec) {
		if(ec != boost::beast::websocket::error::closed) {
			std::cerr << "when_written: " << ec.message() << std::endl;
		}

		do_close(boost::beast::websocket::close_code::going_away);
		return;
	}

	// Clear the outgoing message -- no longer needed
	m_outgoing_message.clear();

	if(this->m_check_server_stopped()) {
		std::cout << "Server is stopped" << std::endl;
		// Do not continue if a stop criterion was reached
		do_close(boost::beast::websocket::close_code::normal);
	} else {
		// Start another read cycle
		async_start_read();
	}
}

/******************************************************************************************/

void async_websocket_server_session::do_close(boost::beast::websocket::close_code cc) {
	std::cout << "async_websocket_server_session: Closing down connection" << std::endl;

	// Store the close code for later reference
	m_close_code = cc;

	// Make sure no more pings are sent and the timer expires
	m_timer.cancel();

	if(m_ws.is_open()) {
		// Close the connection
		m_ws.close(cc);
	}

	if(m_ws.next_layer().is_open()) {
		boost::system::error_code ec;

		// Closing the socket cancels all outstanding operations. They
		// will complete with boost::asio::error::operation_aborted
		m_ws.next_layer().shutdown(
			boost::asio::ip::tcp::socket::shutdown_both
			, ec
		);
		m_ws.next_layer().close(ec);

		if (ec) {
			std::cout
				<< "In async_websocket_server_session::do_close():" << std::endl
				<< "Got error code " << ec.message();

			// Not much more we can do
			throw std::runtime_error("async_websocket_server_session::do_close(): Shutdown of next layer has failed");
		}
	}

	// Make it known to the server that a session is leaving
	m_server_sign_on(false);
}

/******************************************************************************************/

std::string async_websocket_server_session::getAndSerializeWorkItem() {
	// Obtain a container_payload object from the queue, serialize it and send it off
	payload_base *plb_ptr = nullptr;
	if (this->m_get_next_payload_item(plb_ptr) && plb_ptr != nullptr) {
		m_command_container.reset(payload_command::COMPUTE, plb_ptr);
	} else {
		// Let the remote side know whe don't have work
		m_command_container.reset(payload_command::NODATA);
	}

	return m_command_container.to_string();
}

/******************************************************************************************/

std::string async_websocket_server_session::process_request() {
	// Extract the string from the buffer
	auto message = boost::beast::buffers_to_string(m_incoming_buffer.data());

	// De-serialize the object
	try {
		m_command_container.from_string(message);
	} catch(...) {
		throw std::runtime_error("async_websocket_server_session::process_request(): Caught exception while de-serializing");
	}

	// Clear the buffer, so we may later fill it with data to be sent
	m_incoming_buffer.consume(m_incoming_buffer.size());

	// Extract the command
	auto inboundCommand = m_command_container.get_command();

	// Act on the command received
	switch(inboundCommand) {
		case payload_command::GETDATA:
		case payload_command::ERROR: {
			return getAndSerializeWorkItem();
		} break;

		case payload_command::RESULT: {
			// Check that work was indeed done
			if(!m_command_container.is_processed()) {
				throw std::runtime_error("async_websocket_server_session::process_request(): Returned payload is unprocessed");
			}

			// Retrieve the next work item and send it to the client for processing
			return getAndSerializeWorkItem();
		} break;

		default: {
			throw std::runtime_error(
				"async_websocket_server_session::process_request(): Got unknown or invalid command "
				   + boost::lexical_cast<std::string>(inboundCommand)
			);
		} break;
	}
}

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/

async_websocket_server::async_websocket_server(
	const std::string& address
	, unsigned short port
	, std::size_t n_context_threads
	, std::size_t n_producer_threads
	, std::size_t n_max_packages_served
	, payload_type payload_type
	, std::size_t container_size
	, double sleep_time
	, std::size_t full_queue_sleep_ms
	, std::size_t max_queue_size
	, std::size_t ping_interval
	, bool verbose_control_frames
)
	: m_endpoint(boost::asio::ip::make_address(address), port)
   , m_n_listener_threads(n_context_threads>0?n_context_threads:std::thread::hardware_concurrency())
   , m_n_max_packages_served(n_max_packages_served)
	, m_payload_type(payload_type)
	, m_n_producer_threads(n_producer_threads>0?n_producer_threads:std::thread::hardware_concurrency())
	, m_container_size(container_size)
	, m_sleep_time(sleep_time)
	, m_full_queue_sleep_ms(full_queue_sleep_ms)
	, m_max_queue_size(max_queue_size)
	, m_ping_interval(ping_interval)
	, m_verbose_control_frames(verbose_control_frames)
	, m_payload_queue{m_max_queue_size}
{ /* nothing */ }

/******************************************************************************************/

// Start accepting incoming connections
void async_websocket_server::run() {
	boost::system::error_code ec;

	// Reset the package counter
	m_n_packages_served = 0;

	// Indicate that the server may async_start_run
	m_server_stopped = false;

	// Open the acceptor
	m_acceptor.open(m_endpoint.protocol(), ec);
	if(ec || !m_acceptor.is_open()) {
		if(ec) { std::cerr << "async_start_run/m_acceptor.open(): " << ec.message() << std::endl; }
		return;
	}

	// Bind to the server address
	m_acceptor.bind(m_endpoint, ec);
	if(ec) {
		std::cerr << "async_start_run/m_acceptor.bind(): " << ec.message() << std::endl;
		return;
	}

	// Start listening for connections
	m_acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
	if(ec) {
		std::cerr << "async_start_run/m_acceptor.listen(): " << ec.message() << std::endl;
		return;
	}

	// Start producers
	m_producer_threads_vec.reserve(m_n_producer_threads);
	switch(m_payload_type) {
		//------------------------------------------------
		case payload_type::container: {
			for (std::size_t i = 0; i < m_n_producer_threads; i++) {
				m_producer_threads_vec.emplace_back(
					std::thread(
						[this](std::size_t container_size, std::size_t full_queue_sleep_ms){
							this->container_payload_producer(container_size, full_queue_sleep_ms);
						}
						, m_container_size
						, m_full_queue_sleep_ms
					)
				);
			}
		} break;

		//------------------------------------------------
		case payload_type::sleep: {
			for (std::size_t i = 0; i < m_n_producer_threads; i++) {
				m_producer_threads_vec.emplace_back(
					std::thread(
						[this](double sleep_time, std::size_t full_queue_sleep_ms) {
							this->sleep_payload_producer(sleep_time, full_queue_sleep_ms);
						}
						, m_sleep_time
						, m_full_queue_sleep_ms
					)
				);
			}
		} break;

		//------------------------------------------------
		case payload_type::command: { // This is a severe error
			throw std::runtime_error(R"(async_websocket_server::run(): Got invalid payload_type "command")");
		} break;

		//------------------------------------------------
	}


	//---------------------------------------------------------------------------
	// And ... action!

	// Will return immediately
	async_start_accept();

	// Allow to serve requests from multiple threads
	m_context_thread_vec.reserve(m_n_listener_threads-1);
	for(std::size_t t_cnt=0; t_cnt<(m_n_listener_threads-1); t_cnt++) {
		m_context_thread_vec.emplace_back(
			std::thread(
				[this](){
					this->m_io_context.run();
				}
			)
		);
	}

	// Block until all work is done
	m_io_context.run();

	//---------------------------------------------------------------------------
	// Wait for the server to shut down

	// Make sure the stop flag has really been set
	assert(true==this->m_server_stopped);

	// Wait for context threads to finish
	for (auto &t: m_context_thread_vec) { t.join(); }
	m_context_thread_vec.clear();

	// Wait for producer threads to finish
	for (auto &t: m_producer_threads_vec) { t.join(); }
	m_producer_threads_vec.clear();
}

/******************************************************************************************/

void async_websocket_server::async_start_accept() {
	auto self = shared_from_this();
	m_acceptor.async_accept(
		m_socket
		, [self](boost::system::error_code ec) {
			self->when_accepted(ec);
		}
	);
}

/******************************************************************************************/

void async_websocket_server::when_accepted(boost::system::error_code ec) {
	if(m_server_stopped) return;

	if(ec) {
		std::cerr << "when_connection_accepted: " << ec.message() << std::endl;
	} else {
		// Create the async_websocket_server_session and async_start_run it. This call will return immediately.
		std::make_shared<async_websocket_server_session>(
			std::move(m_socket)
			, [this](payload_base *&plb_ptr) -> bool { return this->getNextPayloadItem(plb_ptr); }
			, [this]() -> bool { return this->server_stopped(); }
			, [this](bool sign_on) {
				if(sign_on) {
					this->m_n_active_sessions++;
				} else {
					if(0 == this->m_n_active_sessions) {
						throw std::runtime_error("In async_websocket_server::when_accepted(): Tried to decrement #sessions which is already 0");
					} else {
						// This won't help, though, if m_n_active_sessions becomes 0 after the if-check
						this->m_n_active_sessions--;
					}
				}

				std::cout << this->m_n_active_sessions << " active sessions" << std::endl;
			}
			, m_ping_interval
			, m_verbose_control_frames
		)->async_start_run();
	}

	// Accept another connection
	if(!this->m_server_stopped) async_start_accept();
}

/******************************************************************************************/

bool async_websocket_server::getNextPayloadItem(payload_base*& plb_ptr) {
	// Try to retrieve a work item
	bool success = m_payload_queue.pop(plb_ptr);

	// Update counters and the stop flag, if successful
	if(success) {
		if(m_n_packages_served++ < m_n_max_packages_served){
			if(m_n_packages_served%10 == 0) {
				std::cout << "async_websocket_server served " << m_n_packages_served << " packages" << std::endl;
			}
		} else { // Leave
			// Indicate to all parties that we want to stop
			m_server_stopped = true;
			// Stop accepting new connections
			m_acceptor.close();
			// Finally close the socket
			m_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);
			m_socket.close();
		}
	}

	// Let the audience know
	return success;
}

/******************************************************************************************/

bool async_websocket_server::server_stopped() const {
	return this->m_server_stopped.load();
}

/******************************************************************************************/

void async_websocket_server::container_payload_producer(
	std::size_t containerSize
	, std::size_t full_queue_sleep_ms
) {
	std::random_device nondet_rng;
	std::mt19937 mersenne(nondet_rng());
	std::normal_distribution<double> normalDist(0.,1.);

	bool produce_new_container = true;
	container_payload *sc_ptr = nullptr;
	while (true) {
		using namespace std::literals;

		// Only create a new container if the old one was
		// successfully added to the queue
		if (produce_new_container) {
			sc_ptr = new container_payload(containerSize, normalDist, mersenne);
		}

		if (!m_payload_queue.push(sc_ptr)) { // Container could not be added to the queue
			if(this->m_server_stopped) break;
			produce_new_container = false;
			std::this_thread::sleep_for(std::chrono::milliseconds(full_queue_sleep_ms));
		} else {
			produce_new_container = true;
		}
	}
}

/******************************************************************************************/

void async_websocket_server::sleep_payload_producer(
	double sleep_time
	, std::size_t full_queue_sleep_ms
) {
	bool produce_new_container = true;
	sleep_payload *sp_ptr = nullptr;
	while (!this->m_server_stopped) {
		using namespace std::literals;

		// Only create a new container if the old one was
		// successfully added to the queue
		if (produce_new_container) {
			sp_ptr = new sleep_payload(sleep_time);
		}

		if (!m_payload_queue.push(sp_ptr)) { // Container could not be added to the queue
			if(this->m_server_stopped) break;
			produce_new_container = false;
			std::this_thread::sleep_for(std::chrono::milliseconds(full_queue_sleep_ms));
		} else {
			produce_new_container = true;
		}
	}
}

/******************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************/
